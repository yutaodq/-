---
title: 3. 核心操作符(Core operators)
type: guide
order: 301
---

本章节覆盖
* 介绍流的处理
* 探讨常用的 RxJS 操作符
* 使用 map, reduce 和 filter 构建流畅的方法链
* 其他聚合操作符

在前面两章中，你已经了解到函数式编程和响应式编程是 RxJS 获取灵感的来源。这两种范式都是围绕着数据流，以及通过被称为操作符(operators)的函数链来传播变化。操作符是纯函数(pure function)，会基于当前对象的创建新的可观察对象 - 而对原始对象不做修改。在本章中，你将学习到一些广泛使用的 RxJS 可观察对象的操作符，并使用它们创建出一个管道，可以将事件序列转换为你需要的输出结果。

本章中的一个共同主题是，使用源自于函数式编程的声明式代码风格，来创建可观察对象。可以将任意大小的数据序列，以及随着时间推移生成或发出的数据，都挂载到可观察对象的上下文中，目的是为任何类型的数据源（静态或动态）创建统一的编程模型。在我们深入了解「将经过可观察对象序列(observable sequence)的数据施加转化」的操作符之前，还有一件需要了解的要点是，和许多 AJAX 库不同，可观察对象是可以取消的。

## 3.1 流的取值和取消

假设有人创建了一个长执行时的 AJAX 调用，正在从服务器请求相当大量的数据。但是，在创建这个调用不久，用户点击其他按钮从当前页面离开。这时候这个最初的 AJAX 请求会如何处理？再考虑另外一个例子。你在客户端创建一个间隔轮询，获取某些可用数据，但是发生异常后无法再获取数据。是否还允许这些进程失去控制，然后占用系统资源？答案应该是否定的。

流，当它存在于 RxJS，就是一个已经确定预计使用期限的对象，它的预计使用期限则完全是由编程人员来具体定义。不同于其他语言，JavaScript 有着独特的类型，多数类型都和 JSON 直接一一对应。此外，在内存管理方面 JavaScript 也极少提供支持，因为这在历史上一直是浏览器厂商关心的问题。尽管这两个特性使得 JavaScript 成为一个在学习和使用方面都非常不可思议的简洁语言，然而，在应用程序架构下的水管之间发生的事情，还是令人感到非常模糊。

在像 C 和 C++ 这样的语言中，有着极其细粒度的方式，来控制所使用的特定数据结构，以及数据在内存中确切的使用期限 - 你可以完全控制内存的分配和释放内存中的对象。然而，在 JavaScript 中，对象的使用期限是由垃圾收集器控制的，这是正常情况。垃圾收集器是执行应用程序的运行时引擎所控制的进程。它将定期执行，并且释放所有未使用引用(references)所关联的内存。垃圾收集器通过跟踪应用程序各个对象之间保留的引用来实现 - 这就是所谓的引用计数。当它检测到一个对象不再被引用时，它将成为一个待清理项。如果无法找到不再使用的引用，就会造成内存泄漏。内存泄漏，通常是含糊设计或不清楚引用追踪的表现，可能会造成系统执行失控，此时如果应用程序无法响应，就会导致用户用户或系统去结束你的应用程序。

> 警告 自动垃圾收集这个概念，给了 JavaScript 开发人员一个错觉，我们不需要关心内存管理。这在我们尝试自己编写事件处理代码时，是错误的做法。RxJS 通过实现取消订阅机制或者从任何事件触发器（如 DOM）中有效地清理附加的监听器，将我们从内存管理这个问题中解脱出来。

在较早的浏览器实现中，这曾经是一个大问题，特别是 Internet Explorer 事件处理系统。而现在，现代浏览器能够更加高效地清理事件监听器来回收内存，并且像 RxJS 这样的库也进行相应设计以避免这些问题。

### 3.1.1 预先分配内存的不足之处

在使用 RxJS 时要牢记的一个要点是，流的使用期限并不是以创建可观察对象为开始。而是在可观察对象被订阅(subscribe)时开始。因此，在创建和初始时，流的性能消耗很小，因为它开始处于休眠状态，在没有观察者订阅的情况下不会生成或发出事件。有句老话是：“如果一个观察者是由应用程序创建的，而没有人订阅它，它是否会触发一个事件？

在计算方面，仅在需要时才创建数据的对象，被称为惰性数据源。这种对象与 JavaScript 中的对象有着显著对比。术语 lazy 和 eager 分别指的是，应用程序何时向系统请求内存，以及预先请求多少内存。惰性分配(lazy allocation)是，在空间实际需要（或预期需要）时再去分配，而预先分配(eager allocation)是，只要对象被限定范围，就立刻在前期进行分配。在提前分配方案中，分配有一个前期成本，并且很可能的情况是过度分配，因为你不知道要使用多少空间。而在惰性分配方案中，会等到在运行时(runtime)需要用到空间再去分配。这种方案可以让框架非常智能，避免在某些情况下过度分配空间。为了阐述二者不同之处，我们会展示一个常见的 JavaScript 数组方法 slice()，在预先分配和惰性分配机制下是如何取值的。假设有一个可以从头到尾生成数字数组的 range(start, end) 函数。现在我们要生成无穷多个元素，并将取出前面五个元素，如图 3.1 中的方案。

图 3.1 在一个预先分配方案中，程序会在执行 slice(5) 函数之前停止，因为浏览器已经耗尽了内存。

这里是代码：

```
range(1, Number.POSITIVE_INFINITY).slice(0, 5); //-> 浏览器停止
```

由于 JavaScript 的预先取值特性，这段代码永远不会进入到 range() 函数，因为它会生成无穷多个数字（或者直到内存不足和崩溃）。换句话说，预先取值，意味着在进行下一步之前完整执行前一个表达式的每个部分。然而，如果 JavaScript 函数是惰性的，那么这里的代码只需要生成前五个元素，如图 3.2 所示。

图 3.2 在一个惰性分配方案中，等到表达式的结果真正需要用到时，运行时(runtime)才通过程序执行表达式，并且只会分配需要用到的资源。

在这种情况下，等到表达式的结果真正需要用到时，才会对表达式进行全部取值。而 RxJS 中的策略恰好如此：等到订阅者(subscriber)订阅完可观察对象的表达式后，然后才开始初始化任何所需的数据结构。稍后会看到，使用惰性取值方案，可以帮助 RxJS 对内部数据结构进行优化和重用。

### 3.1.2 惰性分配和订阅可观察对象

RxJS 通过两种方式避免过早分配数据。第一种是，正如我们前面提到的，使用惰性订阅机制。第二种是，可观察对象在触发事件后，立即推送数据，而不是将其静态地保存在内存中。在第 4 章中，我们会讨论缓冲操作符(buffering operators)，这个操作符可以将数据暂时存储一段时间，或者在满足某个条件后短暂地存储数据，这完全取决于你的实现。但是默认情况下，一旦收到数据，就立刻向下游发送数据。

惰性订阅(lazy subscription)，意味着可观察对象将保持休眠状态，等到一个它正在关注的事件被触发后才激活。考虑如下这个例子，每隔半秒，就重复生成一次事件：

```
const source$ = Rx.Observable.create(observer => {
  let i = 0;
  setInterval(() => {
    observer.next(i++); // 每隔 500 毫秒，这里的 interval 就会持续发出事件，直到此 interval 停止，事件才停止。
}, 500); });
```

与数组不同，可观察对象实例是一个可能内存无限增长的动态对象，然而它的内存分配却是固定的。一定要做到这样；否则，为用户的每次点击、按键或鼠标移动产生的数据，都分配内存并且存储，是无法接受的事情。想要激活上面的可订阅对象 source$，观察者必须首先通过 subscribe() 来订阅它。一次订阅调用，会把可观察对象的事件从它的休眠状态中解脱出来，并通知它可以开始产生值 - 在这个示例中，每半秒开始分发事件 1, 2, 3, 4, 5 等。由于可观察对象是对许多不同数据源的抽象，所以会因数据源的类型不同而效果不同（，这里我们只是举例说明）。

惰性订阅的第二个优势是，observable 默认不保存数据。在前面的示例中，interval 每次产生的事件，会立刻进行处理，然后丢弃。这就是我们所谓的「可观察对象本质上是流式，而不是池式」的确切含义。“流式”语义中所隐含着的「默认丢弃」，意味着你无须担心无限增长的内存，会无声无息地占用内存，而导致内存泄漏。在以原生 JavaScript 代码编写事件驱动时，如果在事件管理和处理上疏忽，就可能会发生内存泄漏，特别是在旧版本浏览器中。

### 3.1.3 处理订阅：显式地取消订阅

与分配内存同等重要的，是内存解除分配或重新分配给应用程序。例如，交互丰富的 JavaScript UI 可能会将事件处理函数绑定到数千个元素上。等到用户完成与 UI 某个部分的交互后，这些事件处理函数所创建的对象没有理由继续存在和占用内存。正如前面所讨论的，垃圾收集器在清理内存方面相当智能。不幸的是，只有在发现这些对象的引用是未使用状态，或者没有形成引用循环时才能这样进行清理工作，这通常会频繁出现在（用户自己编写的忘记重置对象状态或忽略引用循环的）事件处理的原生代码中。

用户很容易在初始化对象后，由于忘记它们的存在，而没有删除对它们的引用，从而造成应用程序永远无法恢复该内存（这可能不仅仅是一个小的脚本所关注的问题，也可能是现代重型客户端应用程序的也在关注的问题）。你可以在下面这些简单的代码中，更清晰地认识到这个问题，举个例子，我们可能在某个菜单项监听鼠标右键点击事件，然后显示一个自定义的上下文菜单：

```
document.addEventListener('mouseup', e => {
  if (e.button === 2)
    showCustomContextMenu();
  e.stopPropagation();
});
```

许多开发人员甚至可能无法意识到这个代码中存在的问题。问题在于，为了取消订阅此事件，我们还需要引用传递给事件处理器的函数（也就是内部的 lambda 表达式）。即使我们还记得最终要取消订阅，但由于我们可能很多时候都习惯地使用这个用法，所以我们最终创建了一个无法取消订阅的处理函数。更糟糕的是，如果我们嵌套了事件处理函数，或者还订阅了其他事件，我们会创建出更加复杂以及潜在的内存泄漏。

对于早期的 web 应用程序（Web 1.0 时代），内存释放并不是一个问题，因为页面之间的导航跳转，可以强制页面重新加载，从而清除了　JavaScript　的运行时(runtime)足迹。今天，随着单页面应用程序越来越流行（Web 2.0+ 时代），客户端变得更加功能先进和交互丰富，内存压力逐渐成为真正的威胁；现在可以想象到的是，加载到浏览器中的对象，可以存在于整个应用程序的生命周期内。

这一切并不是危言耸听。我们可以预见（就像从 JavaScript 创立以来的已经做了诸多改进，）垃圾收集器会继续改进（，以解决这些内存回收的问题），许多应用程序将毫无问题地运行。但正确的内存管理对于所有应用程序来说仍然是很好的习惯。

这就是为什么我们需要像 RxJS 这样的久经考验的库。在 RxJS 中，由生产者负责取消订阅。订阅关系(subscription)的管理，是通过调用 subscribe() 后返回的一个类型为 Subscription（在 RxJS 4 中也称为 Disposable）的订阅对象来处理的，此 subscription 订阅对象实现了处理源流(source stream)的机制。如果我们已经结束观察，并且不想再接收事件，我们可以调用 unsubscribe() 来拆除卸下它（指源流）；这被称为显式地取消订阅(explicit cancellation)。下面是一个简化的示例：

```
const mouseClicks = Rx.Observable.fromEvent(document, 'mouseup');
const subscription = mouseClicks.subscribe(someMouseClickObserver);

...片刻后
subscription.unsubscribe(); // 将流(stream)拆除卸下，通过 subscription.unsubscribe(); 释放资源
```

这个拆除卸下(tearing-down)过程，会阻止后续事件继续发送到所有注册过的观察者，并且会立即释放分配给可观察对象的所有资源。subscription 实例专门用于处理整个取消订阅过程，之所以可以这样做的原因，是因为我们会在每个可观察对象中，都定义了如何取消订阅关系(unsubscription)的处理逻辑。此外，正如你将在后面的章节中看到的，对于全体的 observable 都是如此行为，这意味着为流分配的所有资源都可以取消并清除，而无需额外的范例，也没有产生内存中孤立对象的风险。

回想一下，在第 2 章中，我们介绍了 Rx.Observable.create() 方法，此方法可用于创建任意的可观察对象。创建它的最后一步是，指出订阅后返回的 subscription 订阅对象该如何处理可观察对象，这是你必须实现的行为。回到我们的进度指示器代码，像这样，在最后添加取消订阅(unsubscription)机制。

> 代码清单 3.1 对可观察对象进行处理

```
const progressBar$ = Rx.Observable.create(observer => {
  const OFFSET = 3000;
  const SPEED =  50;
  let val = 0;
  let timeoutId = 0;
  function progress() {
    if(++val <= 100) {
      observer.next(val);
      timeoutId = setTimeout(progress, SPEED);
    } else {
      observer.complete();
    }
  };
  timeoutId  = setTimeout(progress, OFFSET);
  return () => { // 调用 unsubscribe 方法时执行的函数。描述了如何取消 timeout 的操作。
     clearTimeout(timeoutId);
  };
});
```

> 代码示例 切记，本章的所有代码，都可以在 RxJS in Action 的 GitHub 仓库（ https://github.com/RxJSInAction/rxjs-in-action ）中找到。

在可观察对象函数体的末尾处添加的函数，会成为返回的 Subscription 对象的 unsubscribe() 方法中的函数体。实质上，每一个可观察对象在创建过程中，都提供了自我销毁的钥匙。每当观察者触发订阅时，订阅对象(subscription)都必然会返回一个可以清除自己的取消方式（类似 try/catch 之后的 finally 子句）。由于每个可观察对象都具有这个内含(self-contained)的自我销毁按钮，所以你也可以组合它的所有订阅关系(subscription)，不管这个可观察对象背后隐含多复杂的逻辑，你都可以正确地解除这些订阅关系(subscription)。

> 自定义的可观察对象 如果使用 create() 创建一个自定义的可观察对象，并且在其中模拟了一个无限的 interval 流，你必须提供正确的取消订阅行为，否则它将无限期地运行，并导致内存泄漏。

迄今为止所展示的多数例子，都是设置时间间隔来产生事件，这些事件通过 clearInterval() 来取消。但是不支持取消的数据源发生了什么？接下来我们来看看。

### 3.1.4 Cancellation mismatch between RxJS and other APIs

RxJS observables provide a straightforward mechanism for cancelling and disposing of event streams. But this simplicity can be deceiving when used in conjunction with other JavaScript APIs. For example, you might encounter problems when trying to cancel observables that wrap promises; look at the next listing.

> 代码清单 3.2 Disposing of a promise

```
const promise = new Promise((resolve, reject) => { // Creates a promise that resolves to 42 after 10
  setTimeout(() => {
    resolve(42);
  }, 10000);
});
promise.then(val => {
  console.log(`In then(): ${val}`); // Handles the resolved promise value
});

const subscription$ = Rx.Observable.fromPromise(promise).subscribe(val => {
   console.log(`In subscribe(): ${val}`); // Wraps an observable around the Promise API
});
subscription$.unsubscribe(); // Attempts to dispose of the observable
```

As you can see from listing 3.2, you dispose of the observable thinking it would also take care of the underlying promise. The observable object itself was properly disposed of; surprisingly, although you attempt to explicitly cancel the event as well, after 10 seconds this program emits the following (apparently, JavaScript promises can’t be broken after all):

```
"In then(): 42"
```

So, what happened? This process is explained in figure 3.3.

Figure 3.3 The cancellation of an observable doesn’t affect the underlying promise.

What happens is that promises were not design to be cancelled. Once a Promise object begins executing (gets into a pending status), it tries to become fulfilled by either resolving or rejecting the underlying result, as the case may be.

RxJS makes it easy to integrate with external APIs, but you must be mindful that there’s a mismatch of design philosophies between an API designed to emit a single value (promise) and one that supports infinite values (observable). This is one use case, but it could also happen if you integrate with other APIs that aren’t RxJS aware. Most of the time, though, you don’t have to worry about cancelling subscriptions yourself because many RxJS operators do this for you.

Now that we’ve covered creating and cancelling streams, in the next section we’ll begin with the more popular operators that are essential to any RxJS program.

## 3.2 Popular RxJS observable operators

Though the subscription and disposal semantics of RxJS are useful in managing resources to avoid leaky event handlers, they’re only part of the story. But keep in mind what thinking reactively is all about; instead of you controlling what goes on a stream by creating a custom observable and pushing events through observer.next(), it’s preferable to relinquish that control and react when the time comes - you want to always be reactive! This means allowing RxJS factory operators (of(), from(), and others) to wrap an event source of interest and create the observable sequence with which to apply the business logic you desire. Hence, being reactive involves defining what a program will do when a value is pushed sometime in the future.

This is where RxJS shines, and it’s because of its fully loaded arsenal of out-of-the-box operators, which you can use to create expressive streams of logical data flows. You can create flows to solve virtually any problem, including creating responsive web forms, drag and drop, and even games.

An operator is a small piece of declarative functionality that allows you to inject logic into an observable’s pipeline. An operator is a pure, higher-order function as well, which means it never changes the observable object it’s operating under (called the source), but rather it returns a new observable that continues the chain. FP best practices come into play at this point because the functions composing your business logic, the building blocks of your solution, should be done using pure functions as much as possible. These operators can be used to inspect, alter, create, or delay events after they leave the data source but before they reach the consumer; in other words, anything in your business logic pipeline is handled by the combination of one or more operators, which drive the execution of the pure functions of your program. And if that’s not enough, RxJS operators are also lazily evaluated!

Recall that in chapter 2 (figure 2.10) we highlighted four fundamental types of computing tasks. We split them into two dimensions depending on whether they performed work synchronously or asynchronously and whether they acted on single values or collections. Manipulating a single value is a relatively trivial task (known as a singleton stream), given that you can inspect its properties and manipulate it directly. In most cases, though, you want streams to act across a range of values rather than just one and done. The computing model behind RxJS encourages you to work with function chains that process data, similar to a conveyor belt in an assembly line, as shown in figure 3.4.

Figure 3.4 An assembly line where operators represent individual stations and each has its own task to perform on each piece of data that passes by

Another important design principle of RxJS is to provide a computing model that’s similar to what you’re accustomed to. Inspired in the Array#extras APIs introduced in ES5, RxJS features its own version of core operators such as map, filter, and reduce. Because these are some of the more frequently used, let’s start with them.

### 3.2.1 Introducing the core operators

Operators come in two varieties: as instance methods or as static methods of the observable type. Part of the RxJS 5 rework was the drastic simplification of the API surface, which consisted of a sheer reduction in the number of operators as well as a simplification of their usage. Hence, most of the operators in RxJS 5 can be invoked as static or as instance methods (when we say instance, we refer to invoking them using the dot (.) notation on an observable instance).

RxJS comes with many operators built in that handle many common tasks such as working with collections, extracting elements from the stream, manipulating and transforming the data, handling errors, and others. In this section, we’ll focus on the three that you’ll use about 80% of the time - map, filter, and reduce - as well as a variation of reduce called scan.

__MAPPING OPERATIONS ON OBSERVABLES__

By far the most common operator that you’ll likely come across when dealing with RxJS is map(). RxJS isn’t the only library to implement it, and all the libraries follow the same FP principles. In FP, map() belongs to a category of operations called transformational because it changes the nature of data running through the observable by applying a function; therefore, it’s a single output value or a one-to-one transformation. In symbolic notation, you write it as map :: x -> f(x), where for a given value x you can associate an input of x with an output of f(x). Consider a quick example that applies a given percentage value onto a set of prices:

```
const addSixPercent = x => x + (x * .06);
Rx.Observable.of(10.0, 20.0, 30.0, 40.0)
  .map(addSixPercent) // Applies this function onto each value of the source observable
  .subscribe(console.log); //-> 10.6, 21.2, 31.8, 42.4
```

Mapping functions is a fundamental process when transforming data from one type to another. For example, say you had a list of user IDs for which you wanted to fetch GitHub information. Mapping a function like ajax() over the set of IDs yields an array of JSON account objects.

In RxJS, you want to map functions across all the elements emitted from an observable. To help you better visualize operators, we’ll use the marble diagrams. Recall that arrows and symbolic characters represent the various operations that convert the input stream into the output stream, as shown in figure 3.5.

Figure 3.5 The map operator will produce a one-to-one transformation that will convert an input value into an output value by a given process. In this case, map takes a URL string and converts it into an array of users by means of the mapping function. In the diagram, operators are encoded inside a box that illustrates the function that’s passed in.

We’ll use these vertical transformations in figure 3.5 to depict operations that take one form of data and convert it to another. By design, this function in RxJS has the exact same signature as that of [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map.):

```
Array.prototype.map         :: a => b; for all a in Array<a>
Rx.Observable.prototype.map :: a => b; for all a in Observable<a>
```

Like with arrays, observable’s map() is immutable, which means it won’t change the original but instead will transform the value passed through it. Also, as you can see in figure 3.5, the output will always be the same size as the input because mapping is a one-to-one relationship that preserves structure. It’s left up to you to decide exactly what the transform function is, depending on your business logic; map() simply guarantees that it will be called on every value passing through the stream as it’s propagated downstream to the next operator in the chain.

We mentioned briefly before that all RxJS operators are pure. To show you what this means, we’ll demonstrate the case of map(). Transforming a String into an ID looks like figure 3.6.

Figure 3.6 Mapping a function from String to Array to a source Observable creates a new Observable with the result of the function.

Now, let’s look at the code for this. Suppose you need to convert a collection of strings into a corresponding comma-separated value (CSV) array. Here’s a simple stream that will accomplish this.

> 代码清单 3.3 Mapping functions over streams

```
Rx.Observable.from([
  'The quick brown fox',
  'jumps over the lazy dog'
])
  .map(str => str.split(' ')) // Maps a set of functions to extract the value from
  .do(arr => console.log(arr.length)) // RxJS .do() is a utility operator that’s useful for effective actions such as logging to the screen. This can be handy for debugging or tracing the values flowing through a stream.
  .subscribe(console.log);
```

For those familiar with design patterns, mapping functions is analogous to the adapter pattern (as shown in the famous “Gang of Four” book titled Design Patterns: Elements of Reusable Object-Oriented Software). In the adapter pattern, an object interacts with two otherwise incompatible interfaces and allows information to flow between them, adapting them to each other. In a similar fashion, you use map() to create a type compatibility between the producer and the consumer of data. The purpose of using it is to convert the raw input data into something the consumers can understand. In this way, the adaptation is done from the producer to the consumer.

But sometimes there can be too much data to process, and you may not be interested in all of it. For this, there’s an operator to discard unwanted events.

__FILTERING OUT UNWANTED EVENTS__

Filtering is the process of removing unwanted items from a stream. The criteria to remove these elements is passed in as a selector function, also called the predicate. Here’s a simple example of how this operator works. Say you need you need to place restrictions on input boxes for numerical quantities. It’s probably a good idea to place a business rule over text boxes rejecting any non-numerical input. Whenever you’re thinking about rejecting, removing, narrowing, or selecting data, you can do that easily using a filtering operator called filter() and inspecting the keyCode property of the keystroke, as shown in the following listing.

> 代码清单 3.4 Filtering events from a stream

```
const isNumericalKeyCode = code => code >= 48 && code <= 57;
const input = document.querySelector('#input');
Rx.Observable.fromEvent(input, 'keyup')
  .pluck('keyCode') // Extracts this property from the object passing through the observable
  .filter(isNumericalKeyCode) // Accepts only keys in the numerical range
  .subscribe(code => console.log(`User typed:
    ${String.fromCharCode(code)}`));
```

Also, you can use it to ignore unwanted mouse clicks, touch events, and others. It could be that you’re interested only in data that meets certain criteria, or you need only a certain subset of the data. In some cases, allowing too much data through can have an adverse effect on the performance of your application. Think about building an API for users to access their account history for the month; if on every request you simply dump their entire account history, you’d quickly find both your API and your clients overwhelmed. To make matters worse, your application won’t scale to the size of data being processed. Filtering could be used to generate different views if the user wanted only debits, credits, or transactions after a certain month.

An easy way to think about filtering is to consider the job interview process (every developer’s favorite activity). When recruiting people for a specific job, one of the first things to look for is the candidates’ previous experience in order to determine if they have the right skill-set for the position. If the job requires programming, then you’d expect that the candidates should have some sort of programming background listed on their resume. If not, you could exclude them from your final interview list.

Suppose you modeled your applicant-screening process as an array; then, you could write your filtering operation using the array’s filter()2 method. Because observables implement the same filtering semantics, you’re already familiar with using a predicate function (also called a discriminant) in filter() that returns true for candidates who will be selected to move on to the next round. Here’s the dataset you’ll use:

```
let candidates = [
  {name: 'Brendan Eich', experience : 'JavaScript Inventor'},
  {name: 'Emmet Brown', experience: 'Historian'},
  {name: 'George Lucas', experience: 'Sci-fi writer'},
  {name: 'Alberto Perez', experience: 'Zumba Instructor'},
  {name: 'Bjarne Stroustrup', experience: 'C++ Developer'}
];
```

Whether this data arrives because of an AJAX call or a DOM event, the observable treats it all the same way. So for now, you’ll stick with a simple array. In this case, you can wrap the data with an observable and keep only the candidates who will be considered for this JavaScript job:

```
const hasJsExperience = bg => bg.toLowerCase().includes('javascript');

const candidates$ = Rx.Observable.from(candidates);
candidates$
  .filter(candidate => hasJsExperience(candidate.experience)) //#A
  .subscribe(console.log); //-> prints "Brendan Eich"
```

Figure 3.7 shows what’s happening behind the scenes. Like map(), filter() works vertically removing values from the resulting stream.

Figure 3.7 The filter operator is used to discard candidates who don’t have any JavaScript experience.

Functions map() and filter() are similar in that they take a single function as their parameter. But whereas the function passed to map converted the input value into an output value, the filter() function is used merely as a criterion that decides whether to keep the event in the stream or not. As you know, JavaScript being loosely typed will accept any “truthy” value as a pass, while any “falsy” values will cause it to reject the event.

> Truthy vs. falsy
> In JavaScript, truthy is any value that can be coerced to a true Boolean value. This includes objects, arrays, non-zero numbers, non-empty strings, and of course the true Boolean value. Meanwhile, falsy would be represented by 0, ' ', null, undefined, or false. In practice, although JavaScript will accept all these types without question, it’s often best for clarity’s sake to return a Boolean value.

map and `filter` work well together in scenarios where you don’t want to apply a mapping function to each element but apply it to only the subset you care about. But filter isn’t the only function married to map; let’s not forget about the powerful map/reduce combinations.

__AGGREGATING RESULTS WITH REDUCE__

Sometimes you aren’t interested in acting on each item in a collection in isolation; sometimes you want to look at the collection in aggregate rather than piecemeal. For instance, suppose you want to take the average value of a collection of numbers or you want to turn a sequence into a mathematical series. This type of operation is called a reduction or an aggregation, with the result as a single value output instead of another collection. Once again, arrays come with a built-in reduce operator for this purpose,3 and observables follow suit. reduce is a bit more involved than the other two; here’s the function signature:

```
Rx.Observable.reduce(accumulatorFunction, [initialValue]);
```

The accumulator function is called on every element, and it’s given the current running total and the new value as parameters. The initial value (optional) is used to begin the accumulation process; we’re using 0 to begin the addition. Here’s a simple example to illustrate how reduce() works. Suppose you want to compute the user’s spending for the month by totaling all their transactions. For this example, these transaction objects have a property called amount.

> 代码清单 3.5 Using reduce() to compute spending

```
const add = (x, y) => x + y;
Rx.Observable.from([
  {
    date: '2016-07-01',
    amount: -320.00,
  }, {
    date: '2016-07-13',
    amount: 1000.00,
  },
  {
    date: '2016-07-22',
    amount: 45.0,
  },
])
  .pluck('amount') // Extracts the amount property
  .reduce(add, 0) // Reduces the set of amount values with an add function
  .subscribe(console.log);
```

It’s important to notice that reduce() with observables works a bit differently than map() and filter(). With arrays, reduce() doesn’t return another array; instead, it produces a single raw value, which is the result of the reduction. The observable’s reduce(), on the other hand, continues the previous pattern of returning a new singleton observable. This distinction will become important in section 3.3 when we talk more about operator chaining. Figure 3.8 is a visual representation of the previous code. Reduction is an operation that moves horizontally through the stream.

Figure 3.8 The reduce operator moving horizontally, accumulating every value through the stream using the add function

Suppose you needed to traverse through the candidate stream and group all the candidates with a technical background (that is, with knowledge of C++ or JavaScript):

```
Rx.Observable.from(candidates)
  .filter(candidate => { // Filters all candidates who have no knowledge of a programming language
    const bg = candidate.experience.toLowerCase();
    return bg.includes('javascript') || bg.includes('c++');
  })
  .reduce((acc, obj) => {
    acc.push(obj.name); // Adds a candidate name to the array
    return acc;
  }, []) // Begins with an empty array (called the seed)
  .subscribe(console.log); //-> ["Brendan Eich", "Bjarne Stroustrup"]
```

As you can see, reduce applies an accumulator function over the observable sequence initialized with the first seed value, which will be used to begin the aggregation process. Because reduce() returns a single value, there’s a need for partial accumulation as well. We’ll look at a variation of reduce() called scan().

__SCANNING AGGREGATE DATA__

RxJS uses scan() to apply an accumulator function over an observable sequence (just like reduce()) but returns each intermediate result as the accumulation process is happening and not all at once. This is useful to obtain progress information about how data is being aggregated with each event.

Changing the previous code to use scan() as a direct swap-in replacement of reduce() reveals the intermediate steps of the accumulation:

```
Rx.Observable.from(candidates)
  .filter(candidate => {
    const bg = candidate.experience.toLowerCase();
    return bg.includes('javascript') || bg.includes('c++');
  })
  .scan((acc, obj) => { // Scan can be used as a direct replacement of reduce. In RxJS 4, you would have had to change the seed parameter to be the first one. This was fixed in RxJS 5, with scan now having the same signature as reduce.
    acc.push(obj.name);
    return acc;
  }, [])
  .subscribe(console.log);
//-> ["Brendan Eich"]
     ["Brendan Eich", "Bjarne Stroustrup"] // As soon as it finds the first event, it emits it and accumulates it. A second emission happens when the second event is found, returning the current state of the accumulation.
```

Aside from scan(), the symmetries between arrays and observables are no coincidence. This signature was chosen specifically because it’s so simple and because it’s one that many JavaScript developers are already familiar with. But here the similarities end. Remember that these methods by themselves don’t cause any work to run on the stream (only a subscriber can); instead, when an operator is called on an observable, it’s configuring the observable for future values. Recall our definition of a stream as a specification of a dynamic value. This is a key distinction between the operators that you’ll see with arrays and those with observables, and you’ll learn in later chapters that arrays represent work happening now, whereas observables represent work in the future.

## 3.3 Sequencing operator pipelines with aggregates

One principle of FP is the ability to construct lazy function chains. In this section, we’ll show you how to mix and match the main observable operators you just learned about together with a few other functions known as aggregates. Aggregate functions let you do useful things like keeping track of a running total, taking only a subset of the total set of data, returning default values, and others. Some functional libraries you might have heard of or used before, such as Lodash.js and Underscore.js, have ample support for this. First, it’s important to understand that observable sequences must be self-contained.

### 3.3.1 Self-contained pipelines and referential transparency

Function chains utilize JavaScript’s power of higher-order functions to act as the single providers of the business logic. You saw examples of this before such as the filter function taking a predicate parameter. Also, observable pipelines should be self-contained, which essentially means they’re side effect–free (keep in mind that if your business logic functions are pure, your entire program is pure and stable as well). A pure pipeline doesn’t allow any references to leak out of the observable’s context. Once an event is lifted into the context, it’s contained and transformed through a sequence of operators. Earlier we showed that it’s possible to group operations together to create more-expressive logic. In RxJS, we call this process operator chaining or fluent programming. The analogy of a self-contained pipeline works great as a visualization aid, as shown in figure 3.9.
    Consider this example:

```
let sinceLast = new Date();
Rx.Observable.fromEvent(document, 'mouseup')
  .filter(e => {
    let timeElapsed = new Date() - sinceLast;
    sinceLast = new Date(); // Careless side effects of reading and writing to an external variable
    return timeElapsed < 200;
  })
  .subscribe(() => console.log('double clicked'));
```

Figure 3.9 A self-contained pipeline is one where all of its operations are side effect–free and work strictly on the data coming from previous operators. Operators might be any of map, filter, reduce, and others you’ll learn about in this book.

This code is an example of poorly designed scope management in which the state variable sinceLast is allowed to live outside the observable’s context. The result is that the observable is no longer stateless, and the lifecycles of the state and the observable are now dependent on each other.

It’s important to understand that when you create an observable, you’re creating an ecosystem or a bounded context. That ecosystem is a closed loop that begins with a subscription and ends with a disposal. If you were to look at the observable through an FP lens, you’d see that the internals of that observable remain completely stateless and walled off somewhat from the rest of the application. The scope of the callbacks that are passed into the operators should remain small and local. Mixing code that has external side effects not only introduces difficult-to-track complexity but also removes one of the key advantages to using observables, which is their well-defined lifespan -  creation and disposal should leave the system in the same state they found it in.

> What is a bounded context?
> A bounded context is a design principle originating from domain-driven design, which states that entities pertaining to a single domain model should be highly cohesive and expose only the necessary interface to interact with other contexts. You can extend this definition to the Observable type as a form of context that hides the nature of the data that’s pushed through it, allowing you to transform it by a ubiquitous language made up from the limited set of operators being exposed and independently of what happens in the outside world.

At a glance, a single subscription to this observable will function correctly, assuming that no other code manipulates sinceLast. But if this observable is subscribed to a second time, the result is no longer the same. An observable must always produce the same results given the same events passing through it (that is, pressing the same key combination should always yield the same data to the observers), a quality known in FP as referential transparency.

Each invocation of subscribe() does more than start an event emitter. It spins off a brand-new pipeline that will be independent of any other pipelines that were created by subsequent calls to subscribe(). This behavior is intentional in order to minimize side effects and be referentially transparent; similarly, the result of an observable should be the result of the data passed through it, not the number of parallel observables that are also active. You’ll see in the next chapter on dealing with time in RxJS that the sort of operation used in the previous code sample is unnecessary.

As mentioned earlier, the operator chain is core to the design of an RxJS operator: every operator must perform some work on the data passing through it and then wrap it into another observable instance that gets returned.[4](https://github.com/ReactiveX/rxjs/blob/master/doc/operator-creation.md#advanced) In this manner, the subscription gets internally passed around from one context to the next. To show how this works, you’ll add your own operator using prototype extension (using ES6, you could also do it by extending from the Observable class); this operator is the logical inverse of filter(), called exclude(), and is shown in the next listing.

> 代码清单 3.6 Custom exclude operator

```
function exclude(predicate) {
  return Rx.Observable.create(subscriber => { // Creates a new observable context to return with the new result
    let source = this; // Because you’re in a lambda function, “this” points to the outer scope.
    return source.subscribe(
      value => {
        try { // Catches errors from user-provided callbacks
          if(!predicate(value)) {
            subscriber.next(value); // Passes the next value to the new operator in the chain
          }
        }
        catch(err) {
          subscriber.error(err);
        }
      },
      err => subscriber.error(err), // Be sure to handle errors appropriately and pass them along.
      () => subscriber.complete()
    );
  });
}
Rx.Observable.prototype.exclude = exclude; // Adds the operator by extending the Observable prototype
```

As you can see from this snippet, every operator creates a brand-new observable, transforming the data in its own way and delegating it to the next subscriber in the chain. You can use it to exclude all even numbers as such:

```
Rx.Observable.from([1, 2, 3, 4, 5])
  .exclude(x => x % 2 === 0)
  .subscribe(console.log);
```

Furthermore, operation chaining in combination with an observable’s lazy evaluation gives RxJS an important performance advantage over arrays, which we’ll discuss next.

### 3.3.2 Performance advantages of sequencing with RxJS

Aside from the declarative style of development that encourages you to write side effect–free code, the primary advantage of using observable operators is that there is little or no performance penalty for chaining two methods like map and filter. Behind the scenes, RxJS produces little overhead because observables themselves are lightweight and inexpensive to create. On the other hand, operator calls on arrays create new instances along the way, which naturally incurs more memory allocations when the collection being processed is large. You can see this with a simple example that uses the full set of parameters for map() and filter() array functions:

```
const original = [1, 2, 3];
const result = original
  .filter((x, idx, arr) => {
    console.log(`filtering ${x}, same as original? ${original === arr}`);
    return x % 2 !== 0;
  })
  .map((x, idx, arr) => {
    console.log(`mapping, same as original?  ${original === arr}`);
    return x * x;
  });
result; //-> [1, 9]

Logging to the console within the pipeline is considered a side effect. We’re bending the rule here a bit to illustrate this concept.

map and filter expose extra parameters such as the current index and the source array. Typical implementations of these methods don’t use these parameters, but it’s good to know they’re there.
```

Running this code logs the following messages:

```
"filtering, same as original? true"
"filtering, same as original? true"
"filtering, same as original? true"
"mapping, same as original? false"
"mapping, same as original? false"
```

You can visualize the difference between both approaches in figure 3.10.

Figure 3.10 The array’s filter and map operators generate intermediate, wasteful data structures. RxJS observables are optimized and process events entirely through all functions at once, avoiding intermediate storage altogether.

RxJS, by contrast, doesn’t create intermediate data structures. As you can see in the previous example, filter() works on the same data structure as the original because it’s first on the chain. This operation returns a brand-new array instance that becomes the new owning object on which you call map. This can be inefficient on very large collections because new data structures are created and used only once before being garbage collected. In RxJS, the underlying data structure is optimized to process each item through the pipeline from the producer to the consumer at once, avoiding the creation of extra data structures along the way. Let’s convert the same code to use observables:

```
Rx.Observable.from(original)
  .filter(x => {
    console.log(`filtering ${x}`);
    return x % 2 !== 0;
  })
  .map(x => {
    console.log(`mapping ${x}`);
    return x * x;
  })
  .subscribe();
```

Running this code shows you that each element (or mouse click, key press, asynchronous data, and others) passes through the pipeline by itself without creating intermediary storage. The first value, 1, passes through filtering and then through mapping before 2 and 3 are looked at:

```
"filtering 1"
"mapping 1"
"filtering 2"
"filtering 3"
"mapping 3"
```

Now this is optimal. This fluent chaining pattern hinges on the return type of all observable methods to always return observables. As you know, in arrays, the reduce operator breaks the chain of commands because it doesn’t return an array, so further chaining becomes impossible. In RxJS, every operator will return an observable instance so that it can support further chaining. This property means that a virtually unlimited variety of combinations can be assembled. Whereas observables are abstractions over various data sources, their operators are just abstractions of those abstractions. That is, just like the adapter methods used to create observables from other library types, an operator is simply an adapter to convert an existing observable into a new one with more-specific functionality.

Before we continue having fun building more chains, we’ll introduce another set of aggregate methods that will become handy for building nice expressive business logic. Table 3.1 briefly explains each of these aggregate functions.

Table 3.1 More aggregate operators

Name | Description
-- | --
take(count) | Filtering operator. Returns a specified amount (count) of contiguous elements from an observable sequence. Later, you’ll see this is useful to extract a finite set of events from an otherwise infinite stream.
first, last | A refinement on the take function. Returns the first element in the observable stream or the last, respectively.
min, max | Filtering operators. Work on observables that emit numbers returning the minimum or maximum value of a finite stream, respectively.
do | Utility operator. Invokes an action for each element in the observable sequence to perform some type of side effect. This operator is for debugging and tracing purposes and can be plugged into any step in the pipeline.

Now, let’s have fun with some examples that put some of these to work.

> 代码清单 3.7 Using aggregate operators

```
Rx.Observable.from(candidates)
  .pluck('experience')
  .take(2) // Takes only the first two elements (another filtering operator)
  .do(val => console.log(`Visiting ${val}`)) // Performs the logging routine and passes along the observable sequence
  .subscribe(); // prints "Visiting JavaScript Guru"
                          "Visiting Historian"
```

> Effectful computations
> The do operator is known as an effectful computation, which means it will typically cause an effect such as I/O, a database insert, append to the DOM, or write to a file - all of these side effects, of course. The reason why do() still preserves the chain is rooted in an FP artifact called the K combinator. In simple terms, this is a function that executes any effect but ignores its outcome, just passing the value along in the stream to the next operator. In a way, it’s a bridge that intercepts the stream that allows you to invoke any function. It’s known in other libraries as the tap() operator.

Being able to use this repertoire of operators is certainly beneficial because it frees you from having to write them yourself, reducing the probably for bugs to occur (you can find a complete list of all the operators used in this book in appendix B - you’re free to use it as a guide). Nevertheless, the functions passed into these operators are solely your responsibility, so please test them thoroughly. We’ll revisit testing further in chapter 9.

In this chapter, we talked at length about several of the core operators that come bundled with RxJS. We purposely avoided specifically enumerating all the operators that are available for mapping, filtering, and other tasks. That job is better left to the reference material on GitHub or on the internet.[5](http://xgrommx.github.io/rx-book/index.html) Instead, we wanted to demonstrate how operators are used in conjunction with observables to build chains of logic that let you write streams declaratively, so that they’re both easy to understand and easy to extend. We chose what we think of as the set of core operators. We explored how you can build complex logic intuitively using fluent operators. These are operators that act primarily on a single observable and don’t introduce any time-based operations. In the next chapter, we’ll explore the time aspect of observables, which allows you to handle future data.

## 3.4 Summary

* Streams provide their own mechanisms for cancellation and disposal, which is an improvement over JavaScript’s native event system.
* The Observable data type enables fluent function chaining that allows the sequential application of operators, using a model similar to that of arrays.
* Unlike JavaScript’s native promises, observables have built-in capabilities for disposal and cancellation.
* Functions injected into the operators of an observable sequence contain the business logic of your application and should be side effect–free.
* Observables are self-contained with indefinitely chainable operators.
